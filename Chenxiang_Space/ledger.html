<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å®¶åº­è´¦æœ¬ Beta</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #1e293b;
      --text: #f1f5f9;
      --dim: #94a3b8;
      --border: 1px solid rgba(255, 255, 255, 0.1);
      --input-bg: #0f172a;
      --input-border: #334155;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
      --bar-bg: #334155;
      --green: #22c55e;
      --red: #ef4444;
      --blue: #3b82f6;
      --orange: #f59e0b;
    }
    html[data-theme="light"] {
      --bg: #f1f5f9;
      --panel: #ffffff;
      --text: #0f172a;
      --dim: #64748b;
      --border: 1px solid #e2e8f0;
      --input-bg: #ffffff;
      --input-border: #cbd5e1;
      --shadow: 0 4px 6px -1px rgba(15, 23, 42, 0.08);
      --bar-bg: #e2e8f0;
    }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
        system-ui, sans-serif;
      margin: 0;
      padding: 10px 12px 40px;
      transition: background 0.25s ease, color 0.25s ease;
    }
    .page-wrap {
      max-width: 900px;
      margin: 48px auto 0;
    }
    .card {
      background: var(--panel);
      border-radius: 14px;
      padding: 14px;
      margin-bottom: 12px;
      border: var(--border);
      box-shadow: var(--shadow);
      transition: background 0.25s ease, border 0.25s ease,
        box-shadow 0.25s ease;
    }
    .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .grid-4 {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .credit-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .credit-row {
      border: 1px solid var(--input-border);
      border-radius: 10px;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      background: rgba(59, 130, 246, 0.04);
    }
    @media (min-width: 768px) {
      .credit-row {
        grid-template-columns: 1fr 1fr;
      }
    }
    @media (min-width: 768px) {
      body {
        padding: 16px 0 60px;
      }
      .grid-4 {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    h2,
    h3,
    h4 {
      margin: 0 0 8px;
      font-weight: 600;
    }
    .label {
      color: var(--dim);
      font-size: 0.78rem;
    }
    .value {
      font-size: 1.2rem;
      font-weight: 600;
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
    }
    .highlight {
      color: var(--green);
    }
    .warning {
      color: var(--red);
    }
    .pace-chip {
      display: none;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--input-border);
      font-weight: 800;
      font-size: 1rem;
      line-height: 1.45;
      letter-spacing: 0.05px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.18);
      color: var(--text);
      text-shadow: none;
      -webkit-font-smoothing: antialiased;
      font-smooth: always;
    }
    .pace-chip .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
      box-shadow: 0 0 0 5px rgba(255, 255, 255, 0.03);
    }
    .pace-chip.ahead {
      display: inline-flex;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(34, 197, 94, 0.05));
      border-color: rgba(34, 197, 94, 0.55);
    }
    .pace-chip.ahead .dot {
      background: var(--green);
    }
    .pace-chip.behind {
      display: inline-flex;
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.05));
      border-color: rgba(239, 68, 68, 0.55);
    }
    .pace-chip.behind .dot {
      background: var(--red);
    }
    input,
    select,
    textarea {
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      color: var(--text);
      padding: 7px 8px;
      border-radius: 8px;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 6px;
      font-size: 0.85rem;
    }
    input::placeholder,
    textarea::placeholder {
      color: var(--dim);
    }
    button {
      background: var(--blue);
      color: #fff;
      border: none;
      padding: 8px 10px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      width: 100%;
    }
    button.secondary {
      background: var(--input-border);
      color: var(--text);
    }
    button:active {
      transform: translateY(1px);
      opacity: 0.9;
    }
    .progress-container {
      margin: 8px 0;
    }
    .burn-toggle {
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }
    .burn-toggle .burn-btn {
      width: auto;
      padding: 6px 10px;
      background: transparent;
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: 8px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease;
    }
    .burn-toggle .burn-btn.active {
      background: var(--blue);
      color: #fff;
      border-color: var(--blue);
    }
    .burn-toggle .burn-btn:active {
      transform: translateY(1px);
      opacity: 0.9;
    }
    .progress-bar {
      height: 12px;
      background: var(--bar-bg);
      border-radius: 6px;
      overflow: hidden;
      margin-top: 4px;
    }
    .progress-fill {
      height: 100%;
      transition: width 0.35s ease;
    }
    .tx-list {
      max-height: 360px;
      overflow-y: auto;
      font-size: 0.85rem;
    }
    .tx-item {
      border-bottom: 1px solid var(--input-border);
      padding: 8px 0;
      display: grid;
      grid-template-columns: 2fr 3fr 2fr;
      column-gap: 6px;
      align-items: center;
    }
    .tx-meta {
      color: var(--dim);
      font-size: 0.7rem;
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--input-border);
    }
    .tab {
      padding: 4px 8px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      color: var(--dim);
      font-size: 0.85rem;
    }
    .tab.active {
      border-color: var(--blue);
      color: var(--blue);
      font-weight: 600;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .nav-btns {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 20;
      display: flex;
      gap: 8px;
    }
    .circle-btn {
      width: 34px;
      height: 34px;
      background: var(--panel);
      color: var(--text);
      border: var(--border);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      font-size: 1rem;
    }
    .metric-label {
      font-size: 0.78rem;
      color: var(--dim);
      margin-bottom: 4px;
    }
    .metric-value {
      font-size: 1.1rem;
      font-weight: 600;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(148, 163, 184, 0.15);
      color: var(--dim);
    }
  </style>
</head>
<body>
  <div class="nav-btns">
    <a href="index.html" class="circle-btn" title="è¿”å›ä¸»é¡µ">ğŸ </a>
    <div
      class="circle-btn"
      id="themeIcon"
      onclick="toggleTheme()"
      title="åˆ‡æ¢ä¸»é¢˜"
    >
      ğŸŒ™
    </div>
  </div>

  <div class="page-wrap">
    <!-- é¡¶éƒ¨èµ„äº§å¡ -->
    <div class="card">
      <div class="row" style="margin-bottom: 8px">
        <div class="label">å½“å‰èµ„äº§æ¦‚è§ˆ</div>
        <div class="label" id="periodDate">è´¦æœŸè®¡ç®—ä¸­...</div>
      </div>
      <div>
        <div class="metric-label">ğŸ’° ç›®å‰ä½™é¢</div>
        <div class="metric-value" id="valBalance">Â¥0.00</div>
        <div class="label" id="valBalanceHint"></div>
      </div>
    </div>

    <!-- æ€»è§ˆ + CFO æç¤º -->
    <div class="card">
      <div class="grid-2">
        <div>
          <div class="label" id="lblRemainTitle">æœ¬æœŸå‰©ä½™é¢„ç®—</div>
          <div class="value" id="valRemaining">--</div>
        </div>
        <div style="text-align: right">
          <div class="label" id="lblDailyTitle">åŠ¨æ€æ—¥å‡å¯èŠ±</div>
          <div class="value" id="valDailyAvg">--</div>
        </div>
      </div>
      <div class="row" style="margin-top: 10px">
        <span class="label">æœ¬æœŸå·²æ¶ˆè´¹ (B å£å¾„)</span>
        <span class="value" id="valSpent">Â¥0.00</span>
      </div>
      <div class="row" style="margin-top: 10px">
        <span class="pill" style="cursor: pointer" onclick="toggleConfig()"
          >âš™ï¸ é…ç½® / è´¦æœŸèŒƒå›´</span
        >
      </div>
      <div
        style="
          margin-top: 12px;
          padding: 8px;
          background: rgba(59, 130, 246, 0.08);
          border-left: 3px solid var(--blue);
          border-radius: 6px;
        "
      >
        <span style="font-size: 1.2rem">ğŸ‘¨â€ğŸ’¼</span>
        <span id="cfoComment" class="label" style="margin-left: 4px"
          >CFO æ­£åœ¨åˆ†æä½ çš„èŠ±é’±é€Ÿåº¦...</span
        >
      </div>
    </div>

    <!-- ä¿¡ç”¨å¡æ¨¡å—ï¼ˆç°å®å£å¾„ Aï¼‰ -->
    <div class="card">
      <div class="row" style="align-items: flex-start">
        <div>
          <h3>ğŸ’³ ä¿¡ç”¨å¡ï¼ˆç°å®å£å¾„ Aï¼Œä¸åˆ¶é€ ç„¦è™‘ï¼‰</h3>
          <div class="label">åˆ°æœŸæ—¥å‰åº”è®¡åˆ©æ¯å›ºå®šæŒ‰ 0 å±•ç¤º</div>
        </div>
        <div class="label" style="text-align: right">
          åˆ©ç‡ä¸è´¦å•/åˆ°æœŸæ—¥å›ºå®šå†™å…¥é¡µé¢ï¼Œä¸å†åœ¨é…ç½®é¢æ¿è°ƒæ•´ã€‚
        </div>
      </div>
      <div id="creditCardPanel" class="credit-grid"></div>
    </div>

    <!-- é…ç½®å¡ -->
    <div
      id="configPanel"
      class="card"
      style="display: none; border-color: var(--orange)"
    >
      <h3>âš™ï¸ è´¦æœ¬é…ç½®</h3>
      <div class="grid-2">
        <div>
          <label class="label">è´¦æœŸèµ·å§‹æ—¥ (æ¯æœˆ)</label>
          <input type="number" id="cfgStartDay" value="10" />
        </div>
        <div>
          <label class="label">å•è´¦æœŸé¢„ç®— (CNY)</label>
          <input type="number" id="cfgBudget" value="3500" />
        </div>
      </div>
      <div class="grid-2">
        <div>
          <label class="label">ä½™é¢é”šç‚¹è¯´æ˜</label>
          <div class="label" style="line-height: 1.45">
            åœ¨äº¤æ˜“åˆ—è¡¨ä¸­æ·»åŠ ä¸€æ¡ account=BALANCE_ANCHOR çš„äº¤æ˜“ä½œä¸ºä½™é¢é”šç‚¹ï¼Œé‡‘é¢å³ä¸ºåŸºå‡†ä½™é¢ã€‚
          </div>
        </div>
      </div>
      <div class="grid-2">
        <div>
          <label class="label">è®¿é—®å¯†ç ï¼ˆå¯é€‰ï¼‰</label>
          <input type="password" id="cfgKey" placeholder="ç•™ç©ºåˆ™ä¸æ ¡éªŒ" />
        </div>
        <div>
          <label class="label">è´¦æœŸèŒƒå›´</label>
          <select id="cfgScope">
            <option value="current">æœ¬è´¦æœŸ</option>
            <option value="all">å…¨éƒ¨è´¦æœŸï¼ˆæ±‡æ€»ï¼‰</option>
          </select>
        </div>
      </div>
      <button onclick="saveSettings()">ä¿å­˜é…ç½®å¹¶é‡ç®—</button>
    </div>

    <!-- å®è§‚ç«é€Ÿ -->
    <div class="card">
      <h3>ğŸï¸ å®è§‚ç«é€Ÿ</h3>
      <div class="progress-container">
        <div class="row">
          <span class="label">ğŸ“… æ—¶é—´è¿›åº¦</span>
          <span class="label" id="lblTimeProg">0%</span>
        </div>
        <div class="progress-bar">
          <div
            class="progress-fill"
            id="barTime"
            style="background: var(--dim); width: 0%"
          ></div>
        </div>
      </div>
      <div class="progress-container">
        <div class="row">
          <span class="label">ğŸ’¸ é¢„ç®—æ¶ˆè€— (B å£å¾„)</span>
          <span class="label" id="lblBudgetProg">0%</span>
        </div>
        <div class="progress-bar">
          <div
            class="progress-fill"
            id="barBudget"
            style="background: var(--green); width: 0%"
          ></div>
        </div>
      </div>
      <div class="pace-chip" id="lblPaceText">
        <span class="dot" aria-hidden="true"></span>
        <span class="text"></span>
      </div>
    </div>

    <!-- æ¶ˆè´¹åšå¼ˆ -->
    <div class="card">
      <div class="row">
        <h3>ğŸ“ˆ æ¶ˆè´¹åšå¼ˆ</h3>
        <span class="label">ç‚¹æŸ±å­å¯ä»¥çœ‹å½“å¤©æ˜ç»†</span>
      </div>
      <div id="chartDiv" style="width: 100%; height: 280px"></div>
      <div id="dayDetail" class="label" style="margin-top: 6px"></div>
    </div>

    <!-- æ¶ˆè´¹çƒ­åŠ›å›¾ -->
    <div class="card">
      <div class="row">
        <h3>ğŸ”¥ æ¶ˆè´¹çƒ­åŠ›å›¾</h3>
        <span class="label">é¢œè‰²è¶Šæ·±è¡¨ç¤ºå½“æ—¥ B å£å¾„æ¶ˆè´¹è¶Šé«˜</span>
      </div>
      <div id="heatmapDiv" style="width:100%; height: 220px"></div>
      <div class="label" id="heatmapHint" style="margin-top: 6px"></div>
    </div>

    <!-- é¢„ç®—ç‡ƒå°½æ›²çº¿ -->
    <div class="card">
      <div class="row" style="align-items: flex-start">
        <div>
          <h3>ğŸ“‰ é¢„ç®—ç‡ƒå°½æ›²çº¿</h3>
          <span class="label">è“è‰²=å®é™…ç´¯è®¡æ”¯å‡ºï¼Œè™šçº¿=ç†æƒ³ç´¯è®¡æ”¯å‡º</span>
        </div>
        <div class="burn-toggle">
          <button
            class="burn-btn"
            id="btnBurnAuto"
            onclick="setBurnView('auto')"
          >
            è‡ªåŠ¨
          </button>
          <button
            class="burn-btn"
            id="btnBurnToDate"
            onclick="setBurnView('toDate')"
          >
            è‡³ä»Šæ—¥
          </button>
          <button
            class="burn-btn"
            id="btnBurnFull"
            onclick="setBurnView('full')"
          >
            å…¨è´¦æœŸ
          </button>
        </div>
      </div>
      <div id="burnChartDiv" style="width:100%; height: 260px"></div>
    </div>

    <!-- é‡ç‚¹æŒ‡æ ‡ + é¥¼å›¾ -->
    <div class="card">
      <h3>ğŸ“Œ é‡ç‚¹æŒ‡æ ‡</h3>
      <div class="grid-4">
        <div>
          <div class="metric-label">ğŸš— æ±½è½¦ç›¸å…³</div>
          <div class="metric-value" id="valCarAmt">Â¥0.00</div>
          <div class="label" id="valCarMeta">0 ç¬” Â· 0%</div>
        </div>
        <div>
          <div class="metric-label">ğŸ® å¨±ä¹ç›¸å…³</div>
          <div class="metric-value" id="valEntAmt">Â¥0.00</div>
          <div class="label" id="valEntMeta">0 ç¬” Â· 0%</div>
        </div>
        <div>
          <div class="metric-label">âš¡ ç”Ÿæ´»ç¼´è´¹</div>
          <div class="metric-value" id="valUtilAmt">Â¥0.00</div>
          <div class="label" id="valUtilMeta">0 ç¬” Â· 0%</div>
        </div>
        <div>
          <div class="metric-label">ğŸš é¥®é£Ÿç›¸å…³</div>
          <div class="metric-value" id="valFoodAmt">Â¥0.00</div>
          <div class="label" id="valFoodMeta">0 ç¬” Â· 0%</div>
        </div>
      </div>
      <div id="pieChart" style="width: 100%; height: 220px; margin-top: 8px"></div>
      <div id="pieDetail" class="label" style="margin-top: 6px"></div>
    </div>

    <!-- å¤§é¢æ¶ˆè´¹å¡ç‰‡ -->
    <div class="card">
      <h3>ğŸ’¸ å¤§é¢æ¶ˆè´¹</h3>
      <div id="bigList" class="label" style="margin-top: 6px"></div>
    </div>

    <!-- æ•°æ®èˆ±ï¼ˆå½•å…¥ï¼‰ -->
    <div class="card">
      <div class="tabs">
        <div
          class="tab active"
          id="tab-btn-single"
          onclick="switchTab('single')"
        >
          âš¡ å¿«é€Ÿè®°ä¸€ç¬”
        </div>
        <div class="tab" id="tab-btn-batch" onclick="switchTab('batch')">
          ğŸ“„ æ‰¹é‡å¯¼å…¥
        </div>
      </div>

      <!-- å•æ¡å½•å…¥ -->
      <div id="tab-single" class="tab-content active">
        <div class="grid-2">
          <input type="date" id="inDate" />
          <input type="number" id="inAmount" placeholder="é‡‘é¢" />
        </div>
        <div class="grid-2">
          <select id="inCat1">
            <option value="ç”Ÿæ´»">ç”Ÿæ´»</option>
            <option value="å¨±ä¹">å¨±ä¹</option>
            <option value="å…¶ä»–">å…¶ä»–</option>
            <option value="æ”¶å…¥">æ”¶å…¥</option>
            <option value="è¿˜æ¬¾">è¿˜æ¬¾</option>
            <option value="å¾€æ¥">å¾€æ¥</option>
          </select>
          <input
            type="text"
            id="inCat2"
            placeholder="äºŒçº§åˆ†ç±» (å¦‚: é¥®æ–™/äº¤é€š)"
            list="cat2List"
          />
          <datalist id="cat2List">
            <option value="é¤é¥®"></option>
            <option value="çƒŸè‰" style="display: none"></option>
            <option value="é¥®æ–™"></option>
            <option value="äº¤é€š"></option>
            <option value="åœè½¦"></option>
            <option value="æ¸¸æˆ"></option>
          </datalist>
        </div>
        <input type="text" id="inDesc" placeholder="ç”¨é€”å¤‡æ³¨" />
        <div class="grid-2">
          <select id="inAcc">
            <option value="å¾®ä¿¡">å¾®ä¿¡</option>
            <option value="æ”¯ä»˜å®">æ”¯ä»˜å®</option>
            <option value="ä½™é¢">ä½™é¢</option>
            <option value="ä¿¡ç”¨å¡">ä¿¡ç”¨å¡</option>
          </select>
          <input type="text" id="inBook" placeholder="è´¦æœ¬ï¼Œå¦‚ï¼šä¸»è´¦" value="ä¸»è´¦" />
        </div>
        <div class="grid-2">
          <select id="inXiao">
            <option value="å¦">éå°è·åŒ…</option>
            <option value="æ˜¯">æ˜¯å°è·åŒ…</option>
          </select>
          <div></div>
        </div>
        <button onclick="submitSingle()">è®°è´¦</button>
      </div>

      <!-- æ‰¹é‡å¯¼å…¥ -->
      <div id="tab-batch" class="tab-content">
        <p class="label">
          æ ¼å¼:
          äº¤æ˜“å·,æ—¥æœŸ,é‡‘é¢,ä¸€çº§,äºŒçº§,ç”¨é€”,è´¦æˆ·,è´¦æœ¬,å°è·åŒ…(æ˜¯/å¦)
        </p>
        <textarea
          id="csvInput"
          rows="5"
          placeholder="20251001-0001,2025-10-01,44.65,å¨±ä¹,å‡ºå»ç©,ç”µå½±+çˆ†ç±³èŠ±,ä½™é¢,ä¸»è´¦,å¦"
        ></textarea>
        <div class="grid-2">
          <button class="secondary" onclick="fillDemo()">å¡«å…¥ç¤ºä¾‹</button>
          <button onclick="submitBatch()">å­˜å…¥æ•°æ®åº“</button>
        </div>
        <div
          id="importResult"
          class="label"
          style="margin-top: 10px; color: var(--green)"
        ></div>
        <pre
          id="importErrors"
          class="label"
          style="
            margin-top: 6px;
            white-space: pre-wrap;
            max-height: 160px;
            overflow: auto;
            color: var(--red);
          "
        ></pre>
      </div>
    </div>

    <!-- æ˜ç»† -->
    <div class="card">
      <div class="row">
        <h3>ğŸ“ æ˜ç»†</h3>
        <div style="font-size: 0.78rem; color: var(--dim)">
          <label
            ><input
              type="checkbox"
              id="chkBscope"
              checked
              onchange="renderAll()"
            />
            ä»…çœ‹ B å£å¾„</label
          >
        </div>
      </div>
      <div id="txList" class="tx-list"></div>
      <button class="secondary" style="margin-top: 8px" onclick="exportCSV()">
        ğŸ“¤ å¯¼å‡º CSV
      </button>
    </div>
  </div>

  <script>
    const LEDGER_API_BASE = "https://czbpght.cn/ledger";
    const BALANCE_ANCHOR_ACCOUNT = "BALANCE_ANCHOR";
    const CREDIT_CARDS = [
      {
        key: "cmb",
        name: "æ‹›å•†ä¿¡ç”¨å¡",
        statement_day: 19,
        due_day: 7,
        daily_rate: 0.0005,
      },
      {
        key: "gf",
        name: "å¹¿å‘ä¿¡ç”¨å¡",
        statement_day: 2,
        due_day: 22,
        daily_rate: 0.0005,
      },
    ];

    let appState = {
      settings: {
        period_start: 10,
        total_budget: 3500,
      },
      scope: "current", // current | all | period:YYYY-MM-DD
      ledgerKey: "",
      transactions: [],
      period: { start: "", end: "", days: 0 },
      today: formatDateLocal(new Date()),
      excludedTxIds: [], // è¢«å‰”é™¤çš„å¤§é¢æ¶ˆè´¹ tx_id åˆ—è¡¨
      periodChoices: [], // æ•°æ®ä¸­å­˜åœ¨çš„æ‰€æœ‰è´¦æœŸ
      lastBScope: [], // æœ€è¿‘ä¸€æ¬¡ç”¨äºå›¾è¡¨çš„ B å£å¾„æ•°æ®
      burnView: "auto", // auto | toDate | full
    };

    window.onload = async () => {
      initTheme();
      initSettings();
      const dateInput = document.getElementById("inDate");
      if (dateInput) dateInput.value = appState.today;
      await loadTransactions();
    };

    /* ========== ä¸»é¢˜ ========== */
    function initTheme() {
      const saved = localStorage.getItem("ledger_theme") || "dark";
      setTheme(saved);
    }
    function toggleTheme() {
      const cur = document.documentElement.getAttribute("data-theme") || "dark";
      const next = cur === "light" ? "dark" : "light";
      setTheme(next);
    }
    function setTheme(theme) {
      document.documentElement.setAttribute("data-theme", theme);
      localStorage.setItem("ledger_theme", theme);
      const btn = document.getElementById("themeIcon");
      if (btn) btn.innerText = theme === "light" ? "â˜€ï¸" : "ğŸŒ™";
      if (appState.lastBScope.length) {
        drawCharts(appState.lastBScope, theme === "light");
        renderKeyMetrics(appState.lastBScope);
        drawLedgerHeatmap(appState.lastBScope, theme === "light");
        drawBurnChart(appState.lastBScope, theme === "light");
      }
    }

    function updateBurnToggle(resolvedView, selectedView) {
      const btnToDate = document.getElementById("btnBurnToDate");
      const btnFull = document.getElementById("btnBurnFull");
      const btnAuto = document.getElementById("btnBurnAuto");
      const resolved = selectedView || resolvedView;
      if (btnToDate && btnFull) {
        btnToDate.classList.toggle("active", resolvedView === "toDate");
        btnFull.classList.toggle("active", resolvedView === "full");
      }
      if (btnAuto) btnAuto.classList.toggle("active", resolved === "auto");
    }

    function setBurnView(view) {
      const allowed = ["auto", "toDate", "full"];
      if (!allowed.includes(view)) return;
      appState.burnView = view;
      localStorage.setItem("ledger_burn_view", view);
      updateBurnToggle(view === "full" ? "full" : "toDate", view);
      if (!appState.period.start || !appState.period.end) return;
      const theme = document.documentElement.getAttribute("data-theme") || "dark";
      drawBurnChart(appState.lastBScope || [], theme === "light");
    }

    /* ========== å·¥å…·å‡½æ•° ========== */
    function formatDateLocal(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${dd}`;
    }
    function parseYMDLocal(ymd) {
      const [y, m, d] = (ymd || "").split("-").map(Number);
      if (!y || !m || !d) return new Date(ymd);
      return new Date(y, m - 1, d);
    }
    function sumAmount(list) {
      return list.reduce((s, t) => s + (Number(t.amount) || 0), 0);
    }
    function isBalanceAnchor(tx) {
      return tx && tx.account === BALANCE_ANCHOR_ACCOUNT;
    }
    function isMetaTx(tx) {
      if (!tx) return false;
      if (isBalanceAnchor(tx)) return true;
      const l1 = String(tx.category_level1 || "");
      const l2 = String(tx.category_level2 || "");
      return l1.endsWith("é”šç‚¹") || l2.endsWith("é”šç‚¹");
    }
    function normalizeDateInput(str) {
      if (!str) return str;
      let s = String(str).trim();
      s = s.replace(/[./]/g, "-");
      const m = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (m) {
        const y = m[1];
        const mm = m[2].padStart(2, "0");
        const dd = m[3].padStart(2, "0");
        return `${y}-${mm}-${dd}`;
      }
      return s;
    }

    function parseDateStrict(str) {
      const normalized = normalizeDateInput(str);
      if (!normalized) return null;
      const d = new Date(`${normalized}T00:00:00`);
      return isNaN(d) ? null : d;
    }

    function getTxSeq(txId) {
      if (!txId) return null;
      const str = String(txId);
      const m = str.match(/-(\d+)$/);
      if (m) return parseInt(m[1], 10);
      const n = parseInt(str, 10);
      return isNaN(n) ? null : n;
    }

    function findLatestBalanceAnchor(txs) {
      const anchors = txs.filter(isBalanceAnchor);
      if (!anchors.length) return null;
      anchors.sort((a, b) => {
        if (a.date !== b.date) return a.date < b.date ? -1 : 1;
        const aSeq = getTxSeq(a.tx_id);
        const bSeq = getTxSeq(b.tx_id);
        if (aSeq !== null && bSeq !== null) return aSeq - bSeq;
        if (aSeq === null && bSeq === null)
          return (a.tx_id || "") < (b.tx_id || "") ? -1 : 1;
        return aSeq === null ? -1 : 1;
      });
      return anchors[anchors.length - 1];
    }

    function isTxAfterAnchor(tx, anchor) {
      if (tx.date > anchor.date) return true;
      if (tx.date < anchor.date) return false;
      const txSeq = getTxSeq(tx.tx_id);
      const anchorSeq = getTxSeq(anchor.tx_id);
      if (txSeq !== null && anchorSeq !== null) return txSeq > anchorSeq;
      if (anchor.tx_id && tx.tx_id) return tx.tx_id > anchor.tx_id;
      return false;
    }

    function compareTxOrder(a, b) {
      if (a.date !== b.date) return a.date < b.date ? -1 : 1;
      const aSeq = getTxSeq(a.tx_id);
      const bSeq = getTxSeq(b.tx_id);
      if (aSeq !== null && bSeq !== null) return aSeq - bSeq;
      if (aSeq === null && bSeq === null)
        return (a.tx_id || "") < (b.tx_id || "") ? -1 : 1;
      return aSeq === null ? -1 : 1;
    }

    function findLatestCardAnchor(txs, accountName) {
      const anchors = txs.filter((tx) => {
        if (tx.account !== accountName) return false;
        if (tx.book !== "ä¸»è´¦") return false;
        if (Number(tx.is_xiaoe) === 1) return false;
        const l1 = String(tx.category_level1 || "");
        const l2 = String(tx.category_level2 || "");
        return l1 === "æ¬ æ¬¾é”šç‚¹" || l2 === "æ¬ æ¬¾é”šç‚¹";
      });
      if (!anchors.length) return null;
      return anchors.sort(compareTxOrder)[anchors.length - 1];
    }

    function buildCardCycle(card, refDate) {
      if (!card) return null;
      let year = refDate.getFullYear();
      let month = refDate.getMonth();

      for (let i = 0; i < 24; i++) {
        const statementDate = new Date(year, month, card.statement_day);
        let dueMonth = month;
        let dueYear = year;
        if (card.due_day <= card.statement_day) {
          dueMonth += 1;
          if (dueMonth > 11) {
            dueMonth = 0;
            dueYear += 1;
          }
        }
        const dueDate = new Date(dueYear, dueMonth, card.due_day);
        const periodStart = new Date(statementDate);
        periodStart.setDate(periodStart.getDate() + 1);

        if (dueDate >= refDate) {
          return { statementDate, periodStart, dueDate };
        }

        month += 1;
        if (month > 11) {
          month = 0;
          year += 1;
        }
      }
      return null;
    }

    function buildCardData(card) {
      const txs = appState.transactions.filter((tx) => {
        if (tx.account !== card.name) return false;
        if (tx.book !== "ä¸»è´¦") return false;
        return Number(tx.is_xiaoe) !== 1;
      });
      const anchor = findLatestCardAnchor(txs, card.name);
      const anchorAmount = anchor ? Number(anchor.amount) || 0 : 0;
      const events = txs
        .filter((tx) => {
          if (anchor && !isTxAfterAnchor(tx, anchor)) return false;
          const l1 = String(tx.category_level1 || "");
          const l2 = String(tx.category_level2 || "");
          return !(l1 === "æ¬ æ¬¾é”šç‚¹" || l2 === "æ¬ æ¬¾é”šç‚¹");
        })
        .sort(compareTxOrder)
        .map((tx) => {
          const amt = Math.abs(Number(tx.amount) || 0);
          let delta = amt;
          if (tx.category_level1 === "è¿˜æ¬¾") delta = -amt;
          else if (tx.category_level1 === "æ”¶å…¥" && tx.account === card.name)
            delta = -amt;
          return { date: tx.date, delta };
        });
      return { anchor, anchorAmount, events };
    }

    function computeBalanceUntil(events, base, dateStr) {
      let bal = base;
      for (const ev of events) {
        if (ev.date > dateStr) break;
        bal += ev.delta;
      }
      return bal;
    }

    function calcCardInterest(cardData, startDate, endDate, rate) {
      if (!cardData) return 0;
      const events = cardData.events || [];
      let bal = cardData.anchorAmount || 0;
      const startStr = formatDateLocal(startDate);
      const endStr = formatDateLocal(endDate);
      let idx = 0;
      while (idx < events.length && events[idx].date < startStr) {
        bal += events[idx].delta;
        idx++;
      }

      let total = 0;
      const cursor = new Date(startDate);
      while (cursor <= endDate) {
        const ds = formatDateLocal(cursor);
        while (idx < events.length && events[idx].date === ds) {
          bal += events[idx].delta;
          idx++;
        }
        total += Math.max(bal, 0) * rate;
        cursor.setDate(cursor.getDate() + 1);
      }
      return total;
    }

    /* ========== é…ç½®åˆå§‹åŒ– ========== */
    function initSettings() {
      try {
        const saved = localStorage.getItem("ledger_settings");
        if (saved) {
          const s = JSON.parse(saved);
          if (typeof s.period_start === "number")
            appState.settings.period_start = s.period_start;
          if (typeof s.total_budget === "number")
            appState.settings.total_budget = s.total_budget;
        }
      } catch (e) {}
      const key = localStorage.getItem("ledger_key") || "";
      appState.ledgerKey = key;

      let scope = localStorage.getItem("ledger_scope") || "current";
      appState.scope = scope;

      const burnPref = localStorage.getItem("ledger_burn_view") || "auto";
      if (["auto", "toDate", "full"].includes(burnPref)) {
        appState.burnView = burnPref;
      }

      // å‰”é™¤çš„å¤§é¢ tx_id åˆ—è¡¨
      try {
        const excl = localStorage.getItem("ledger_excluded_tx");
        if (excl) {
          const arr = JSON.parse(excl);
          if (Array.isArray(arr)) appState.excludedTxIds = arr;
        }
      } catch (e) {
        appState.excludedTxIds = [];
      }

      // å†™å›é…ç½®é¢æ¿
      document.getElementById("cfgStartDay").value =
        appState.settings.period_start;
      document.getElementById("cfgBudget").value =
        appState.settings.total_budget;
      document.getElementById("cfgKey").value = key;
      document.getElementById("cfgScope").value = scope;

      renderAssets();
    }

    function saveSettings() {
      const start = parseInt(
        document.getElementById("cfgStartDay").value,
        10
      );
      const budget = parseFloat(document.getElementById("cfgBudget").value);
      const key = (document.getElementById("cfgKey").value || "").trim();
      const scopeVal = document.getElementById("cfgScope").value || "current";

      appState.settings = {
        period_start: isNaN(start) ? 10 : start,
        total_budget: isNaN(budget) ? 3500 : budget,
      };
      appState.ledgerKey = key;
      appState.scope = scopeVal;

      localStorage.setItem(
        "ledger_settings",
        JSON.stringify(appState.settings)
      );
      localStorage.setItem("ledger_key", key);
      localStorage.setItem("ledger_scope", scopeVal);

      toggleConfig();
      loadTransactions();
    }

    /* ========== é¡¶éƒ¨èµ„äº§å¡ï¼šä½™é¢ & å¹¿å‘ ========== */
    function renderAssets() {
      let displayBal = 0;
      const balanceHint = document.getElementById("valBalanceHint");
      if (balanceHint) balanceHint.textContent = "";

      const anchor = findLatestBalanceAnchor(appState.transactions);
      if (anchor) {
        const baseBalance = Number(anchor.amount) || 0;
        let delta = 0;
        for (const tx of appState.transactions) {
          if (isMetaTx(tx)) continue;
          if (!isTxAfterAnchor(tx, anchor)) continue;
          if (tx.category_level1 === "æ”¶å…¥") {
            delta += tx.amount;
          } else {
            delta -= tx.amount;
          }
        }
        displayBal = baseBalance + delta;
      } else {
        displayBal = 0;
        if (balanceHint) balanceHint.textContent = "æœªè®¾ç½®ä½™é¢é”šç‚¹";
      }

      document.getElementById("valBalance").innerText =
        "Â¥" + displayBal.toFixed(2);
    }

    function renderCreditCards() {
      const container = document.getElementById("creditCardPanel");
      if (!container) return;
      const today = parseYMDLocal(appState.today);
      const blocks = CREDIT_CARDS.map((card) => {
        const cardData = buildCardData(card);
        const cycle = buildCardCycle(card, today);
        if (!cycle)
          return `<div class="credit-row"><div class="label">æœªèƒ½è§£æ ${card.name} çš„è´¦å•å‘¨æœŸã€‚</div></div>`;
        const balance = computeBalanceUntil(
          cardData.events,
          cardData.anchorAmount,
          formatDateLocal(today)
        );
        const beforeStatement = today < cycle.statementDate;
        const anchorLate =
          cardData.anchor &&
          parseYMDLocal(cardData.anchor.date) > cycle.periodStart;
        const anchorHint = cardData.anchor
          ? `æœ€æ–°æ¬ æ¬¾é”šç‚¹ï¼š${cardData.anchor.date} Â· Â¥${cardData.anchorAmount.toFixed(
              2
            )}`
          : "æœªæ‰¾åˆ°æ¬ æ¬¾é”šç‚¹ï¼Œé»˜è®¤ä» 0 å¼€å§‹ç´¯è®¡ã€‚";

        let potentialBlock = "<div class=\"label\">æœ¬æœŸæœªå‡ºè´¦ï¼Œåˆ©æ¯é¢„æµ‹ä¸å±•ç¤º</div>";
        if (!beforeStatement) {
          const predicted = calcCardInterest(
            cardData,
            cycle.periodStart,
            cycle.dueDate,
            card.daily_rate
          );
          const warnText = anchorLate
            ? `é”šç‚¹æ™šäºæœ¬æœŸèµ·ç®—æ—¥ï¼ˆ${formatDateLocal(
                cycle.periodStart
              )}ï¼‰ï¼Œè‹¥åˆ°æœŸæœªå…¨é¢è¿˜æ¸…ï¼Œé¢„è®¡åˆ©æ¯å¯èƒ½ä½ä¼°ã€‚`
            : "";
          potentialBlock = `<div class=\"label\">æ½œåœ¨åˆ©æ¯ï¼ˆè‹¥åˆ°æœŸæœªå…¨é¢è¿˜æ¸…ï¼‰ï¼šÂ¥${predicted.toFixed(
            2
          )}</div>${
            warnText
              ? `<div class=\"label warning\">${warnText}</div>`
              : ""
          }`;
        }
        return `<div class="credit-row">
            <div>
              <div class="metric-label">${card.name}</div>
              <div class="metric-value">æ¬ æ¬¾ Â¥${balance.toFixed(2)}</div>
              <div class="label">è´¦å•æ—¥ ${card.statement_day} Â· åˆ°æœŸæ—¥ ${
          card.due_day
        } Â· æ—¥åˆ©ç‡ ${card.daily_rate}</div>
              <div class="label">${anchorHint}</div>
            </div>
            <div style="text-align:right; align-self:center;">
              <div class="label">ä¸‹ä¸€æ¬¡åˆ°æœŸæ—¥ï¼š${formatDateLocal(
                cycle.dueDate
              )}</div>
              <div class="label">å½“å‰åº”è®¡åˆ©æ¯ï¼šÂ¥0.00</div>
              ${potentialBlock}
            </div>
          </div>`;
      });
      container.innerHTML = blocks.join("");
    }

    function toggleConfig() {
      const el = document.getElementById("configPanel");
      el.style.display = el.style.display === "none" ? "block" : "none";
    }

    /* ========== å…¬å…± API ========== */
    function buildHeaders(isJson) {
      const h = {};
      if (isJson) h["Content-Type"] = "application/json";
      if (appState.ledgerKey) h["x-ledger-key"] = appState.ledgerKey;
      return h;
    }

    async function apiGet(path, params = {}) {
      const url = new URL(LEDGER_API_BASE + path);
      Object.entries(params).forEach(([k, v]) => {
        if (v !== undefined && v !== null && v !== "")
          url.searchParams.set(k, v);
      });
      try {
        const res = await fetch(url.toString(), {
          headers: buildHeaders(false),
        });
        if (res.status === 401) {
          alert("è®¿é—®è¢«æ‹’ç»ï¼Œè¯·åœ¨ã€é…ç½®ã€é‡Œæ£€æŸ¥è®¿é—®å¯†ç ã€‚");
          return null;
        }
        if (!res.ok) {
          alert("æ¥å£é”™è¯¯ï¼š" + res.status);
          return null;
        }
        return await res.json();
      } catch (e) {
        alert("ç½‘ç»œé”™è¯¯ï¼š" + e.message);
        return null;
      }
    }

    async function apiPostJson(path, body) {
      try {
        const res = await fetch(LEDGER_API_BASE + path, {
          method: "POST",
          headers: buildHeaders(true),
          body: JSON.stringify(body),
        });
        if (res.status === 401) {
          alert("è®¿é—®è¢«æ‹’ç»ï¼Œè¯·åœ¨ã€é…ç½®ã€é‡Œæ£€æŸ¥è®¿é—®å¯†ç ã€‚");
          return null;
        }
        if (!res.ok) {
          alert("æ¥å£é”™è¯¯ï¼š" + res.status);
          return null;
        }
        return await res.json().catch(() => ({ ok: true }));
      } catch (e) {
        alert("ç½‘ç»œé”™è¯¯ï¼š" + e.message);
        return null;
      }
    }

    /* ========== äº¤æ˜“åŠ è½½ & è´¦æœŸæ„å»º ========== */
    async function loadTransactions() {
      const data = await apiGet("/transactions", {});
      appState.transactions = (data || []).map(normalizeTx);

      rebuildPeriodOptions();
      calculatePeriod();
      renderAll();
    }

    function normalizeTx(t) {
      const parsedDate = parseDateStrict(t.date);
      return {
        tx_id: t.tx_id || t.id || null,
        date: parsedDate ? formatDateLocal(parsedDate) : normalizeDateInput(t.date),
        amount: Number(t.amount),
        category_level1: t.category_level1 || "",
        category_level2: t.category_level2 || "",
        description: t.description || "",
        account: t.account || "",
        book: t.book || "",
        is_xiaoe: Number(t.is_xiaoe) === 1,
      };
    }

    function rebuildPeriodOptions() {
      const txs = getStatTransactions();
      const sel = document.getElementById("cfgScope");
      if (!sel) return;

      const startDay = appState.settings.period_start;
      const periodMap = new Map(); // startStr -> { start, end }

      txs.forEach((tx) => {
        const d = new Date(tx.date);
        if (isNaN(d)) return;
        const ps = getPeriodStartForDate(d, startDay);
        const startStr = formatDateLocal(ps);
        if (!periodMap.has(startStr)) {
          const end = new Date(ps);
          end.setMonth(end.getMonth() + 1);
          end.setDate(end.getDate() - 1);
          periodMap.set(startStr, {
            start: startStr,
            end: formatDateLocal(end),
          });
        }
      });

      const periods = Array.from(periodMap.values()).sort((a, b) =>
        a.start < b.start ? -1 : 1
      );
      appState.periodChoices = periods;

      const prevValue = sel.value;
      sel.innerHTML = "";

      // æœ¬è´¦æœŸ
      const optCur = document.createElement("option");
      optCur.value = "current";
      optCur.textContent = "æœ¬è´¦æœŸ";
      sel.appendChild(optCur);

      // å†å²è´¦æœŸ
      periods.forEach((p) => {
        const opt = document.createElement("option");
        opt.value = "period:" + p.start;
        opt.textContent = `è´¦æœŸ ${p.start} ~ ${p.end}`;
        sel.appendChild(opt);
      });

      // å…¨éƒ¨è´¦æœŸ
      const optAll = document.createElement("option");
      optAll.value = "all";
      optAll.textContent = "å…¨éƒ¨è´¦æœŸï¼ˆæ±‡æ€»ï¼‰";
      sel.appendChild(optAll);

      const allValues = Array.from(sel.options).map((o) => o.value);
      let newValue = prevValue;
      if (!allValues.includes(newValue)) newValue = "current";
      sel.value = newValue;
      appState.scope = newValue;
    }

    function calculatePeriod() {
      const scope = appState.scope;
      const labelEl = document.getElementById("periodDate");

      const statTxs = getStatTransactions();

      if (!statTxs.length) {
        appState.period = { start: "", end: "", days: 0 };
        labelEl.innerText = "å½“å‰æš‚æ— äº¤æ˜“æ•°æ®";
        return;
      }

      if (scope === "all") {
        let minDateStr = statTxs[0].date;
        let maxDateStr = statTxs[0].date;
        for (const tx of statTxs) {
          if (tx.date < minDateStr) minDateStr = tx.date;
          if (tx.date > maxDateStr) maxDateStr = tx.date;
        }
        const start = new Date(minDateStr);
        const end = new Date(maxDateStr);
        const days = Math.round((end - start) / 86400000) + 1;
        appState.period = {
          start: minDateStr,
          end: maxDateStr,
          days: days,
        };
        labelEl.innerText = `å…¨éƒ¨è´¦æœŸ: ${minDateStr} ~ ${maxDateStr}`;
        return;
      }

      if (scope.startsWith("period:")) {
        const startStr = scope.slice("period:".length);
        const found =
          appState.periodChoices.find((p) => p.start === startStr) || null;
        let sStr = startStr;
        let eStr = null;
        if (found) {
          sStr = found.start;
          eStr = found.end;
        } else {
          const sDate = new Date(startStr);
          const eDate = new Date(sDate);
          eDate.setMonth(eDate.getMonth() + 1);
          eDate.setDate(eDate.getDate() - 1);
          eStr = formatDateLocal(eDate);
        }
        const sDate = new Date(sStr);
        const eDate = new Date(eStr);
        const days = Math.round((eDate - sDate) / 86400000) + 1;
        appState.period = { start: sStr, end: eStr, days };
        labelEl.innerText = `è´¦æœŸ: ${sStr} ~ ${eStr}`;
        return;
      }

      // scope === "current"
      const today = new Date();
      const startDay = appState.settings.period_start;
      let start = new Date(
        today.getFullYear(),
        today.getMonth(),
        startDay
      );
      if (today.getDate() < startDay) {
        start.setMonth(start.getMonth() - 1);
      }
      let end = new Date(start);
      end.setMonth(end.getMonth() + 1);
      end.setDate(end.getDate() - 1);
      const startStr = formatDateLocal(start);
      const endStr = formatDateLocal(end);
      const days = Math.round((end - start) / 86400000) + 1;
      appState.period = { start: startStr, end: endStr, days };
      labelEl.innerText = `æœ¬è´¦æœŸ: ${startStr} ~ ${endStr}`;
    }

    function inCurrentPeriod(tx) {
      const scope = appState.scope;
      if (scope === "all") return true;
      const s = appState.period.start;
      const e = appState.period.end;
      const startDate = parseDateStrict(s);
      const endDate = parseDateStrict(e);
      const txDate = parseDateStrict(tx.date);
      if (!startDate || !endDate || !txDate) return false;
      return txDate >= startDate && txDate <= endDate;
    }

    /* ========== B å£å¾„ + å‰”é™¤å¤§é¢ ========== */
    function isExcluded(tx) {
      if (!tx.tx_id) return false;
      return (
        Array.isArray(appState.excludedTxIds) &&
        appState.excludedTxIds.indexOf(tx.tx_id) !== -1
      );
    }

    function getStatTransactions() {
      return appState.transactions.filter((tx) => !isMetaTx(tx));
    }

    function filterBBase(list) {
      return list.filter((tx) => {
        if (isMetaTx(tx)) return false;
        if (isBalanceAnchor(tx)) return false;
        if (["æ”¶å…¥", "è¿˜æ¬¾", "å¾€æ¥"].includes(tx.category_level1))
          return false;
        if (tx.is_xiaoe) return false;
        return true;
      });
    }

    function filterBScope(list) {
      return filterBBase(list).filter((tx) => !isExcluded(tx));
    }

    function getPeriodStartForDate(d, startDay) {
      const y = d.getFullYear();
      const m = d.getMonth();
      const dd = d.getDate();
      let start = new Date(y, m, startDay);
      if (dd < startDay) {
        start.setMonth(start.getMonth() - 1);
      }
      return start;
    }

    function diffMonths(a, b) {
      return (
        (b.getFullYear() - a.getFullYear()) * 12 +
        (b.getMonth() - a.getMonth())
      );
    }

    function calcGlobalPeriodInfo(bData) {
      if (!bData.length) return null;
      let minDateStr = bData[0].date;
      let maxDateStr = bData[0].date;
      for (const tx of bData) {
        if (tx.date < minDateStr) minDateStr = tx.date;
        if (tx.date > maxDateStr) maxDateStr = tx.date;
      }
      const minDate = new Date(minDateStr);
      const maxDate = new Date(maxDateStr);
      const startDay = appState.settings.period_start;
      const firstStart = getPeriodStartForDate(minDate, startDay);
      const lastStart = getPeriodStartForDate(maxDate, startDay);
      const periods = diffMonths(firstStart, lastStart) + 1;
      const lastEnd = new Date(lastStart);
      lastEnd.setMonth(lastEnd.getMonth() + 1);
      lastEnd.setDate(lastEnd.getDate() - 1);
      const totalBudgetAll = periods * appState.settings.total_budget;
      return { periods, totalBudgetAll, firstStart, lastEnd };
    }

    /* ========== ä¸»æ¸²æŸ“é€»è¾‘ ========== */
    function renderAll() {
      const statTxs = getStatTransactions();
      const periodTx = statTxs.filter(inCurrentPeriod);
      const bBase = filterBBase(periodTx); // åŸå§‹ B å£å¾„ï¼ˆå«å¤§é¢ï¼‰
      const ledgerBBase = filterBBase(statTxs); // å…¨é‡è´¦æœ¬ B å£å¾„
      const bData = bBase.filter((tx) => !isExcluded(tx)); // çœŸæ­£å‚ä¸é¢„ç®—çš„ B å£å¾„

      appState.lastBScope = bData;

      const totalSpent = sumAmount(bData);

      // æ›´æ–°èµ„äº§å¡ï¼ˆä½™é¢è·Ÿéšæµæ°´ï¼‰
      renderAssets();
      renderCreditCards();

      const remainLabelEl =
        document.getElementById("lblRemainTitle");
      const dailyLabelEl =
        document.getElementById("lblDailyTitle");

      let remaining = 0;
      let timeProg = 0;
      let budgetProg = 0;
      let dailyAvg = 0;
      let daysPassed = 0;
      let daysTotal = appState.period.days || 0;
      let budgetTotal = 0;

      const scope = appState.scope;

      if (scope === "all") {
        const info = calcGlobalPeriodInfo(bData);
        if (!info) {
          document.getElementById("valRemaining").innerText = "Â¥0.00";
          document.getElementById("valDailyAvg").innerText = "Â¥0.00";
          document.getElementById("valSpent").innerText = "Â¥0.00";
          document.getElementById("barTime").style.width = "0%";
          document.getElementById("barBudget").style.width = "0%";
          document.getElementById("chartDiv").innerHTML =
            '<div class="label">å…¨éƒ¨è´¦æœŸæš‚æ—  B å£å¾„æ¶ˆè´¹ï¼Œå›¾è¡¨æ— æ³•ç»˜åˆ¶ã€‚</div>';
          renderKeyMetrics(bData);
          renderBigPurchases(ledgerBBase);
          runCFOComment(0, 0);
          renderList([]);
          return;
        }
        const { periods, totalBudgetAll, firstStart, lastEnd } = info;
        const startStr = formatDateLocal(firstStart);
        const endStr = formatDateLocal(lastEnd);
        const days = Math.round((lastEnd - firstStart) / 86400000) + 1;
        appState.period = { start: startStr, end: endStr, days };
        daysTotal = days;
        daysPassed = days;
        budgetTotal = totalBudgetAll;
        remaining = budgetTotal - totalSpent;

        timeProg = 100;
        budgetProg =
          budgetTotal > 0 ? (totalSpent / budgetTotal) * 100 : 0;
        dailyAvg = periods > 0 ? totalSpent / periods : 0;

        document.getElementById("periodDate").innerText =
          `å…¨éƒ¨è´¦æœŸ: ${startStr} ~ ${endStr}ï¼ˆå…± ${periods} ä¸ªè´¦æœŸï¼‰`;
        remainLabelEl.innerText =
          "ç´¯è®¡å‰©ä½™é¢„ç®—ï¼ˆæŒ‰è´¦æœŸé¢„ç®—æŠ˜ç®—ï¼‰";
        dailyLabelEl.innerText = "å¹³å‡æ¯è´¦æœŸæ¶ˆè´¹";
      } else {
        daysTotal = appState.period.days || 0;
        const startDate = new Date(appState.period.start);
        const endDate = new Date(appState.period.end);
        const now = new Date();
        if (now <= startDate) {
          daysPassed = 0;
        } else if (now >= endDate) {
          daysPassed = daysTotal;
        } else {
          let diffDays = Math.floor((now - startDate) / 86400000);
          if (diffDays < 0) diffDays = 0;
          if (diffDays > daysTotal - 1) diffDays = daysTotal - 1;
          daysPassed = diffDays + 1;
        }

        const remainingDays = Math.max(
          1,
          daysTotal - Math.max(daysPassed, 1) + 1
        );
        budgetTotal = appState.settings.total_budget;
        remaining = budgetTotal - totalSpent;
        dailyAvg = remaining / remainingDays;
        timeProg =
          daysTotal > 0 ? (daysPassed / daysTotal) * 100 : 0;
        budgetProg =
          budgetTotal > 0 ? (totalSpent / budgetTotal) * 100 : 0;

        remainLabelEl.innerText = "æœ¬æœŸå‰©ä½™é¢„ç®—";
        dailyLabelEl.innerText = "åŠ¨æ€æ—¥å‡å¯èŠ±";
      }

      const remainEl = document.getElementById("valRemaining");
      remainEl.innerText = "Â¥" + remaining.toFixed(2);
      remainEl.className =
        remaining < 0 ? "value warning" : "value highlight";
      document.getElementById("valDailyAvg").innerText =
        "Â¥" + dailyAvg.toFixed(2);
      document.getElementById("valSpent").innerText =
        "Â¥" + totalSpent.toFixed(2);

      // è¿›åº¦æ¡ + å…·ä½“æ•°å€¼
      const timeBar = document.getElementById("barTime");
      const budgetBar = document.getElementById("barBudget");
      const timePct = Math.max(
        0,
        Math.min(100, timeProg || 0)
      ).toFixed(1);
      const budgetPct = Math.max(
        0,
        Math.min(100, budgetProg || 0)
      ).toFixed(1);

      timeBar.style.width = `${timePct}%`;
      document.getElementById(
        "lblTimeProg"
      ).innerText = `${daysPassed}/${daysTotal || 0} å¤© (${timePct}%)`;

      budgetBar.style.width = `${budgetPct}%`;
      budgetBar.style.background =
        budgetProg > timeProg ? "var(--red)" : "var(--green)";
      document.getElementById(
        "lblBudgetProg"
      ).innerText = `Â¥${totalSpent.toFixed(
        2
      )} / Â¥${budgetTotal.toFixed(2)} (${budgetPct}%)`;

      // æ—¶é—´ä¸èŠ±è´¹å¯¹æ¯”æ–‡æ¡ˆ
      const paceTextEl = document.getElementById("lblPaceText");
      const paceTextSpan = paceTextEl.querySelector(".text");
      let paceText = "";
      let paceState = "";
      if (daysTotal > 0 && budgetTotal > 0) {
        const dailyBudget = budgetTotal / daysTotal;
        if (dailyBudget > 0) {
          const theoreticalSpent = dailyBudget * daysPassed;
          const diff = theoreticalSpent - totalSpent;
          if (diff >= 0) {
            const aheadAmount = diff;
            const aheadDays = aheadAmount / dailyBudget;
            const aheadDaysDisplay = aheadDays.toFixed(1);
            const aheadAmountDisplay = aheadAmount.toFixed(2);
            paceText = `ä½ å·²è·‘èµ¢æ—¶é—´çº¦ ${aheadDaysDisplay} å¤© â‰ˆ çœä¸‹ ${aheadAmountDisplay} å…ƒ`;
            paceState = "ahead";
          } else {
            const behindAmount = -diff;
            const behindDays = behindAmount / dailyBudget;
            const behindDaysDisplay = behindDays.toFixed(1);
            const behindAmountDisplay = behindAmount.toFixed(2);
            paceText = `ä½ å·²è¶…å‰èŠ±è´¹çº¦ ${behindDaysDisplay} å¤© â‰ˆ å¤šèŠ±äº† ${behindAmountDisplay} å…ƒ`;
            paceState = "behind";
          }
        }
      }
      paceTextSpan.innerText = paceText;
      paceTextEl.className = paceText
        ? `pace-chip ${paceState}`
        : "pace-chip";
      paceTextEl.style.display = paceText ? "inline-flex" : "none";

      renderKeyMetrics(bData);
      renderBigPurchases(ledgerBBase);
      runCFOComment(timeProg, budgetProg);
      const theme =
        document.documentElement.getAttribute("data-theme") ||
        "dark";
      drawCharts(bData, theme === "light");
      drawLedgerHeatmap(bData, theme === "light");
      drawBurnChart(bData, theme === "light");

      const showB = document.getElementById("chkBscope").checked;
      const incomeTx = periodTx.filter((tx) => tx.category_level1 === "æ”¶å…¥");
      const listData = showB
        ? bData.concat(incomeTx)
        : periodTx.slice();

      const sortedList = listData.slice().sort((a, b) => {
        if (a.date === b.date) {
          const aId = a.tx_id || "";
          const bId = b.tx_id || "";
          return aId > bId ? -1 : aId < bId ? 1 : 0;
        }
        return a.date > b.date ? -1 : 1;
      });

      renderList(sortedList);
    }

    /* ========== åˆ†ç±»é€»è¾‘ï¼šè½¦ / å¨±ä¹ / ç¼´è´¹ / é¥®é£Ÿ / é¥®æ–™ / å…¶ä»– ========== */
// ç»Ÿä¸€çš„æ¶ˆè´¹åˆ†ç±»ï¼Œç”¨äºé¥¼å›¾ & é‡ç‚¹æŒ‡æ ‡
function classifyCategory(tx) {
  const c1 = tx.category_level1 || "";
  const c2 = tx.category_level2 || "";
  const desc = tx.description || "";
  // å…¨éƒ¨è½¬æˆå°å†™ï¼Œæ–¹ä¾¿åŒ¹é…è‹±æ–‡
  const text = (c1 + " " + c2 + " " + desc).toLowerCase();

  // ğŸš— æ±½è½¦ç›¸å…³
  if (
    /åœè½¦|è½¦ä½|é«˜é€Ÿ|ä¿å…»|æ´—è½¦|ä¿®è½¦|ç‰¹æ–¯æ‹‰|å……ç”µ|æ²¹è´¹|è½¦ä½ç”µè´¹|å¹´æ£€|ä¿é™©/.test(
      text
    )
  ) {
    return "car";
  }

  // âš¡ ç”Ÿæ´»ç¼´è´¹
  if (/æ°´è´¹|ç”µè´¹|ç‡ƒæ°”|ç…¤æ°”|å®½å¸¦|ç½‘è´¹|è¯è´¹|æµé‡|å›ºè¯/.test(text)) {
    return "util";
  }

  // ğŸ§ƒ é¥®æ–™ / å¥¶èŒ¶
  if (
    /é¥®æ–™|å¥¶èŒ¶|å’–å•¡|å¯ä¹|é›ªç¢§|æ±½æ°´|æœæ±|èŒ¶|æ˜Ÿå·´å…‹|å–œèŒ¶|å¥ˆé›ª/.test(
      text
    )
  ) {
    return "drink";
  }

  // ğŸ® å¨±ä¹ï¼šå¦‚æœä¸€çº§åˆ†ç±»å°±æ˜¯â€œå¨±ä¹â€ï¼Œç›´æ¥ç®—å¨±ä¹
  if (
    c1.includes("å¨±ä¹") ||
    /æ¸¸æˆ|å¨±ä¹|ktv|é…’å§|ç”µå½±|å½±é™¢|æ¼”å”±ä¼š|å‰§æœ¬æ€|æ¡Œæ¸¸|é—¨ç¥¨|å±•è§ˆ|å¯†å®¤/.test(
      text
    )
  ) {
    return "ent";
  }

  // ğŸš é¥®é£Ÿï¼šä¼˜å…ˆçœ‹äºŒçº§åˆ†ç±»â€œé£Ÿç‰©/é¤é¥®â€ï¼Œå†çœ‹æè¿°é‡Œçš„å…³é”®è¯
  if (
    c2.includes("é£Ÿç‰©") ||
    c2.includes("é¤é¥®") ||
    /æ—©é¤|æ—©é¥­|åˆé¤|åˆé¥­|æ™šé¤|æ™šé¥­|ä¸­é¤|å¤œå®µ|å®µå¤œ|å¤–å–|ç‚¹é¤|åƒé¥­|æ­£é¤|ç±³çº¿|ç±³ç²‰|é¢é¦†|çƒ§çƒ¤|ç«é”…|è‡ªåŠ©|æ±‰å ¡|ç‚¸é¸¡|ç›–é¥­|é¥­åº—|é¤å…|å°åƒ|é›¶é£Ÿ|ä¾¿å½“/.test(
      text
    )
  ) {
    return "food";
  }

  // å…¶å®ƒéƒ½å½’ä¸ºâ€œå…¶ä»–â€
  return "other";
}


    function renderKeyMetrics(bData) {
      const total = sumAmount(bData);
      const keys = ["car", "ent", "util", "food", "drink", "other"];
      const buckets = {};
      keys.forEach((k) => {
        buckets[k] = { amt: 0, cnt: 0 };
      });

      bData.forEach((tx) => {
        const k = classifyCategory(tx);
        const b = buckets[k];
        b.amt += tx.amount;
        b.cnt += 1;
      });

      const setMetric = (key, amtId, metaId) => {
        const b = buckets[key];
        const amtEl = document.getElementById(amtId);
        const metaEl = document.getElementById(metaId);
        amtEl.innerText = "Â¥" + b.amt.toFixed(2);
        const ratio =
          total > 0 ? ((b.amt / total) * 100).toFixed(1) : "0.0";
        metaEl.innerText = `${b.cnt} ç¬” Â· ${ratio}%`;
      };

      // é‡ç‚¹æŒ‡æ ‡å¡ç‰‡åªå±•ç¤ºè¿™å››ä¸ª
      setMetric("car", "valCarAmt", "valCarMeta");
      setMetric("ent", "valEntAmt", "valEntMeta");
      setMetric("util", "valUtilAmt", "valUtilMeta");
      setMetric("food", "valFoodAmt", "valFoodMeta");

      // é¥¼å›¾ï¼šè½¦ / å¨±ä¹ / ç¼´è´¹ / é¥®é£Ÿ / é¥®æ–™ / å…¶ä»–
      const pieDiv = document.getElementById("pieChart");
      const pieDetail = document.getElementById("pieDetail");

      if (!total || total <= 0) {
        pieDiv.innerHTML = "";
        pieDetail.innerText = "";
        return;
      }

      const pieCfg = [
        { key: "car", label: "æ±½è½¦" },
        { key: "ent", label: "å¨±ä¹" },
        { key: "util", label: "ç”Ÿæ´»ç¼´è´¹" },
        { key: "food", label: "é¥®é£Ÿ" },
        { key: "drink", label: "é¥®æ–™/å¥¶èŒ¶" },
        { key: "other", label: "å…¶ä»–" },
      ];

      const labels = [];
      const vals = [];
      pieCfg.forEach((c) => {
        const b = buckets[c.key];
        if (b.amt > 0.01) {
          labels.push(c.label);
          vals.push(b.amt);
        }
      });

      if (!vals.length) {
        pieDiv.innerHTML = "";
        pieDetail.innerText = "";
        return;
      }

      const theme =
        document.documentElement.getAttribute("data-theme") ||
        "dark";
      const textColor = theme === "light" ? "#64748b" : "#cbd5f5";
      const layout = {
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        font: { color: textColor },
        margin: { t: 10, l: 10, r: 10, b: 10 },
        showlegend: false,
      };
      const trace = {
        labels,
        values: vals,
        type: "pie",
        textinfo: "label+percent",
        insidetextorientation: "radial",
      };
      Plotly.newPlot("pieChart", [trace], layout, {
        displayModeBar: false,
      });

      pieDiv.on("plotly_click", function (evt) {
        if (!evt || !evt.points || !evt.points.length) return;
        const label = evt.points[0].label;
        showPieCategoryDetail(label);
      });
    }

    function showPieCategoryDetail(label) {
      const labelMap = {
        æ±½è½¦: "car",
        å¨±ä¹: "ent",
        ç”Ÿæ´»ç¼´è´¹: "util",
        é¥®é£Ÿ: "food",
        "é¥®æ–™/å¥¶èŒ¶": "drink",
        å…¶ä»–: "other",
      };
      const key = labelMap[label];
      const pieDetail = document.getElementById("pieDetail");
      if (!key || !pieDetail) return;
      const data = appState.lastBScope || [];
      const list = data.filter(
        (tx) => classifyCategory(tx) === key
      );
      if (!list.length) {
        pieDetail.innerText = `${label}ï¼šå½“å‰èŒƒå›´å†…æš‚æ— è®°å½•`;
        return;
      }
      const sum = sumAmount(list);
      const rows = list
        .slice(0, 20)
        .map(
          (tx) =>
            `${tx.date} Â· ${tx.category_level1}-${tx.category_level2 || "-"} Â· ${
              tx.description || ""
            } Â· Â¥${tx.amount.toFixed(2)}`
        );
      let extra = "";
      if (list.length > 20)
        extra = `ï¼ˆä»…æ˜¾ç¤ºå‰ 20 æ¡ï¼Œå…± ${list.length} æ¡ï¼‰`;
      pieDetail.innerText =
        `${label} åˆè®¡ Â¥${sum.toFixed(2)}ï¼Œå…± ${list.length} ç¬”${extra}ï¼š\n` +
        rows.join("\n");
    }

    /* ========== å¤§é¢æ¶ˆè´¹å¡ç‰‡ ========== */
    function renderBigPurchases(bBase) {
      const container = document.getElementById("bigList");
      if (!container) return;

      const data = Array.isArray(bBase) ? bBase : [];
      if (!data.length) {
        container.innerHTML = "è´¦æœ¬æš‚æ—  B å£å¾„æ¶ˆè´¹è®°å½•ã€‚";
        return;
      }

      const excludedSet = new Set(appState.excludedTxIds || []);
      const today = parseYMDLocal(appState.today);
      const BIG_THRESHOLD = 500; // é»˜è®¤å¤§é¢é˜ˆå€¼

      const excluded = data
        .filter((tx) => tx.tx_id && excludedSet.has(tx.tx_id))
        .sort((a, b) => new Date(b.date) - new Date(a.date));
      const candidates = data
        .filter(
          (tx) =>
            tx.tx_id &&
            !excludedSet.has(tx.tx_id) &&
            tx.amount >= BIG_THRESHOLD
        )
        .sort((a, b) => b.amount - a.amount);

      let selectedHtml = "";
      if (excluded.length) {
        selectedHtml +=
          '<div class="label" style="margin-bottom:6px;">å·²æ ‡è®°ä¸ºå¤§é¢æ¶ˆè´¹ï¼ˆä¸è®¡å…¥é¢„ç®—ä¸å›¾è¡¨ï¼‰</div>';
        excluded.forEach((tx) => {
          const d = new Date(tx.date);
          const diffDays = Math.max(
            1,
            Math.floor((today - d) / 86400000) + 1
          );
          const perDay = tx.amount / diffDays;
          const title =
            tx.description ||
            tx.category_level2 ||
            tx.category_level1 ||
            "æœªå‘½åæ¶ˆè´¹";
          selectedHtml += `<div style="margin-bottom:6px;">
              <label>
                <input type="checkbox" data-txid="${tx.tx_id}" onchange="toggleExclude(this)" checked />
                ${tx.date} Â· ${title} Â· Â¥${tx.amount.toFixed(2)}
              </label>
              <div class="tx-meta">å·²æ‹¥æœ‰ ${diffDays} å¤© Â· æ—¥å‡æ‘Š Â¥${perDay.toFixed(
            2
          )}/å¤©</div>
            </div>`;
        });
      } else {
        selectedHtml = '<div class="tx-meta">æš‚æ— å·²æ ‡è®°çš„å¤§é¢æ¶ˆè´¹æ¡ç›®ã€‚</div>';
      }

      let candidateHtml =
        '<details class="big-dropdown" open>\n' +
        '  <summary style="cursor:pointer; font-weight:600; color: var(--text);">é€‰æ‹©å€™é€‰å¤§é¢æ”¯å‡ºï¼ˆé‡‘é¢ â‰¥ Â¥500ï¼‰</summary>\n';
      candidateHtml +=
        '  <div class="tx-meta" style="margin:6px 0 8px;">æ£€ç´¢èŒƒå›´ï¼šæ•´ä¸ªè´¦æœ¬ï¼Œå‹¾é€‰åå°†è¿›å…¥å·¦ä¾§åˆ—è¡¨å¹¶ä»å…¶ä»–è®¡ç®—ç»´åº¦å‰”é™¤ã€‚</div>';
      if (!candidates.length) {
        candidateHtml +=
          '  <div class="tx-meta">æš‚æ— ç¬¦åˆé‡‘é¢é˜ˆå€¼çš„å€™é€‰æ¡ç›®ã€‚</div>';
      } else {
        candidateHtml += '  <div style="margin-top:4px;">';
        candidates.forEach((tx) => {
          const title =
            tx.description ||
            tx.category_level2 ||
            tx.category_level1 ||
            "æœªå‘½åæ¶ˆè´¹";
          candidateHtml += `<div style="margin-bottom:4px;">
              <label>
                <input type="checkbox" data-txid="${tx.tx_id}" onchange="toggleExclude(this)" />
                ${tx.date} Â· ${title} Â· Â¥${tx.amount.toFixed(2)}
              </label>
            </div>`;
        });
        candidateHtml += "  </div>";
      }
      candidateHtml += "</details>";

      container.innerHTML = `<div class="grid-2" style="gap:12px; align-items:flex-start;">
          <div>${selectedHtml}</div>
          <div>${candidateHtml}</div>
        </div>`;
    }

    function toggleExclude(checkbox) {
      const txId = checkbox.getAttribute("data-txid");
      if (!txId) return;
      let arr = Array.isArray(appState.excludedTxIds)
        ? appState.excludedTxIds.slice()
        : [];
      if (checkbox.checked) {
        if (!arr.includes(txId)) arr.push(txId);
      } else {
        arr = arr.filter((id) => id !== txId);
      }
      appState.excludedTxIds = arr;
      localStorage.setItem("ledger_excluded_tx", JSON.stringify(arr));
      renderAll();
    }

    /* ========== CFO æ€»è¯„ ========== */
    function runCFOComment(timeProg, budgetProg) {
      const delta = (budgetProg - timeProg).toFixed(1);
      let c = "";
      if (budgetProg === 0 && timeProg === 0) {
        c = "è¿˜æ²¡æœ‰äº§ç”Ÿ B å£å¾„æ¶ˆè´¹ï¼ŒCFO åœ¨æ—è¾¹çœ‹æˆã€‚";
      } else if (delta < -5) {
        c = `ä½ é¢†å…ˆæ—¶é—´ ${Math.abs(
          delta
        )}%ï¼ŒèŠ±å¾—æŒºå…‹åˆ¶ï¼Œå¯ä»¥è€ƒè™‘ç»™è‡ªå·±ä¸€ç‚¹å°å¥–åŠ±ã€‚`;
      } else if (Math.abs(delta) <= 5) {
        c = "èŠ‚å¥åˆšåˆšå¥½ï¼Œæ¶ˆè´¹åŸºæœ¬è·Ÿæ—¶é—´åŒæ­¥ï¼Œä¿æŒè¿™ä¸ªçŠ¶æ€å°±å¾ˆèˆ’æœã€‚";
      } else {
        c = `å·²ç»æ¯”æ—¶é—´å¿«äº† ${delta}% ï¼Œåé¢å‡ å¤©è¦ç¨å¾®è¸©ä¸€ä¸‹åˆ¹è½¦ã€‚`;
      }
      document.getElementById("cfoComment").innerText = c;
    }

    /* ========== æ¶ˆè´¹åšå¼ˆå›¾ ========== */
    function drawCharts(bData, isLight) {
      const chartDiv = document.getElementById("chartDiv");
      const dayDetail = document.getElementById("dayDetail");

      if (!bData.length) {
        chartDiv.innerHTML =
          '<div class="label">å½“å‰èŒƒå›´å†…æš‚æ—  B å£å¾„æ¶ˆè´¹ã€‚</div>';
        dayDetail.innerText = "";
        return;
      }
      const textColor = isLight ? "#64748b" : "#cbd5f5";
      const gridColor = isLight ? "#e2e8f0" : "#334155";

      const dailyMap = {};
      bData.forEach((t) => {
        if (!dailyMap[t.date]) dailyMap[t.date] = 0;
        dailyMap[t.date] += t.amount;
      });
      const dates = Object.keys(dailyMap).sort();
      const amounts = dates.map((d) => dailyMap[d]);

      const info = calcGlobalPeriodInfo(bData);
      const totalBudget =
        appState.scope === "all"
          ? info
            ? info.totalBudgetAll
            : appState.settings.total_budget
          : appState.settings.total_budget;
      const totalDays =
        appState.scope === "all"
          ? info
            ? info.periods * 30
            : dates.length
          : appState.period.days || dates.length;

      const dynLine = [];
      let cum = 0;
      for (let i = 0; i < dates.length; i++) {
        cum += amounts[i];
        const remainingBudget = totalBudget - cum;
        const remainingDays = totalDays - (i + 1);
        dynLine.push(remainingDays > 0 ? remainingBudget / remainingDays : 0);
      }

      const zhDates = dates.map((d) => {
        const [y, m, dd] = d.split("-");
        return Number(m) + "æœˆ" + Number(dd) + "æ—¥";
      });

      const traceBar = {
        x: zhDates,
        y: amounts,
        type: "bar",
        name: "å½“æ—¥æ¶ˆè´¹",
        marker: { color: "#3b82f6" },
      };
      const traceLine = {
        x: zhDates,
        y: dynLine,
        type: "scatter",
        mode: "lines",
        name: "åŠ¨æ€æ—¥å‡å¯èŠ±",
        line: { color: "#f97316", dash: "solid" },
      };
      const layout = {
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        font: { color: textColor },
        margin: { t: 10, l: 36, r: 10, b: 40 },
        showlegend: false,
        xaxis: {
          gridcolor: gridColor,
          tickangle: -45,
          automargin: true,
        },
        yaxis: {
          gridcolor: gridColor,
          automargin: true,
        },
      };
      Plotly.newPlot("chartDiv", [traceBar, traceLine], layout, {
        displayModeBar: false,
      });

      chartDiv.on("plotly_click", function (evt) {
        if (!evt || !evt.points || !evt.points.length) return;
        const idx = evt.points[0].pointIndex;
        const dateStr = dates[idx];
        showDayDetail(dateStr);
      });
    }

    function drawBurnChart(bData, isLight) {
      const div = document.getElementById("burnChartDiv");
      if (!div) return;

      const periodStart = parseYMDLocal(appState.period.start);
      const periodEnd = parseYMDLocal(appState.period.end);
      const MS_PER_DAY = 86400000;
      const totalDays =
        Math.floor((periodEnd - periodStart) / MS_PER_DAY) + 1;

      if (totalDays <= 0) {
        div.innerHTML = '<div class="label">å½“å‰è´¦æœŸèŒƒå›´æ— æ•ˆã€‚</div>';
        return;
      }

      // æ±‡æ€»æ¯æ—¥ B å£å¾„æ”¯å‡º
      const daily = new Array(totalDays).fill(0);
      if (Array.isArray(bData)) {
        bData.forEach((tx) => {
          if (!tx.date) return;
          if (tx.category_level1 === "æ”¶å…¥") return;

          const amt = Number(tx.amount || 0);
          if (!Number.isFinite(amt) || amt <= 0) return;

          const d = parseYMDLocal(tx.date);
          if (d < periodStart || d > periodEnd) return;

          const idx = Math.floor((d - periodStart) / MS_PER_DAY);
          if (idx < 0 || idx >= totalDays) return;

          daily[idx] += amt;
        });
      }

      const dates = [];
      const actual = [];
      const ideal = [];

      const totalBudgetB = (() => {
        if (appState.scope === "all") {
          const info = calcGlobalPeriodInfo(bData);
          if (info && Number.isFinite(info.totalBudgetAll))
            return info.totalBudgetAll;
        }
        return appState.settings.total_budget || 0;
      })();

      let cum = 0;
      for (let i = 0; i < totalDays; i++) {
        const d = new Date(periodStart);
        d.setDate(periodStart.getDate() + i);
        const ds = formatDateLocal(d);
        dates.push(ds);

        cum += daily[i] || 0;
        actual.push(cum);

        const progress = (i + 1) / totalDays;
        ideal.push(totalBudgetB * progress);
      }

      const textColor = isLight ? "#0f172a" : "#e2e8f0";
      const gridColor = isLight
        ? "rgba(148,163,184,0.25)"
        : "rgba(148,163,184,0.45)";

      const today = parseYMDLocal(appState.today);
      let todayIdxRaw = Math.floor((today - periodStart) / MS_PER_DAY);
      if (!Number.isFinite(todayIdxRaw)) todayIdxRaw = 0;
      const daysFromStart = Math.max(0, todayIdxRaw);
      let todayIdx = Math.min(Math.max(todayIdxRaw, 0), totalDays - 1);

      const budgetRatio =
        totalBudgetB > 0 ? (actual[todayIdx] || 0) / totalBudgetB : 0;

      const viewPref = appState.burnView || "auto";
      let viewMode = viewPref;
      if (viewMode === "auto") {
        viewMode =
          daysFromStart <= 7 || budgetRatio < 0.15 ? "toDate" : "full";
      }

      const sliceEnd = viewMode === "toDate" ? todayIdx + 1 : totalDays;
      const viewDates = dates.slice(0, sliceEnd);
      const viewActual = actual.slice(0, sliceEnd);
      const viewIdeal = ideal.slice(0, sliceEnd);

      const traceActual = {
        x: viewDates,
        y: viewActual,
        type: "scatter",
        mode: "lines+markers",
        name: "å®é™…ç´¯è®¡æ”¯å‡º",
        line: { width: 2 },
        marker: { size: 6 },
        hovertemplate: "%{x}<br>ç´¯è®¡æ”¯å‡ºï¼šÂ¥%{y:.2f}<extra></extra>",
      };

      const traceIdeal = {
        x: viewDates,
        y: viewIdeal,
        type: "scatter",
        mode: "lines",
        name: "ç†æƒ³ç´¯è®¡æ”¯å‡º",
        line: { width: 2, dash: "dot" },
        hovertemplate: "%{x}<br>ç†æƒ³ç´¯è®¡ï¼šÂ¥%{y:.2f}<extra></extra>",
      };

      const shapes = [];
      if (
        viewMode === "full" &&
        today instanceof Date &&
        today >= periodStart &&
        today <= periodEnd
      ) {
        const todayStr = formatDateLocal(today);
        shapes.push({
          type: "line",
          xref: "x",
          yref: "paper",
          x0: todayStr,
          x1: todayStr,
          y0: 0,
          y1: 1,
          line: {
            color: isLight ? "#94a3b8" : "#cbd5f5",
            width: 1.5,
            dash: "dash",
          },
        });
      }

      updateBurnToggle(viewMode === "full" ? "full" : "toDate", viewPref);

      const layout = {
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        font: { color: textColor },
        margin: { t: 8, l: 40, r: 10, b: 32 },
        xaxis: {
          showgrid: false,
          zeroline: false,
          tickangle: -45,
        },
        yaxis: {
          showgrid: true,
          gridcolor: gridColor,
          zeroline: false,
        },
        legend: {
          orientation: "h",
          x: 0,
          y: 1.1,
        },
        shapes,
      };

      Plotly.react(div, [traceActual, traceIdeal], layout, {
        displayModeBar: false,
      });
    }

    function drawLedgerHeatmap(bData, isLight) {
      const div = document.getElementById("heatmapDiv");
      const hint = document.getElementById("heatmapHint");
      if (!div) return;

      // èšåˆæ¯æ—¥æ”¯å‡º
      const daily = {};
      if (Array.isArray(bData)) {
        bData.forEach((tx) => {
          if (!tx.date) return;
          if (tx.category_level1 === "æ”¶å…¥") return;

          const amt = Number(tx.amount || 0);
          if (!Number.isFinite(amt) || amt <= 0) return;

          daily[tx.date] = (daily[tx.date] || 0) + amt;
        });
      }

      const amounts = Object.values(daily);
      if (!amounts.length) {
        div.innerHTML = '<div class="label">å½“å‰èŒƒå›´å†…æš‚æ—  B å£å¾„æ¶ˆè´¹ã€‚</div>';
        if (hint) {
          hint.innerText =
            appState.scope === "all"
              ? `èŒƒå›´ï¼šå…¨éƒ¨è´¦æœŸï¼ˆ${appState.period.start} ~ ${appState.period.end}ï¼‰ï¼›é¢œè‰²ç”±ç»¿åˆ°çº¢å†åˆ°ç´«ï¼Œè¡¨ç¤ºåœ¨å½“å‰èŒƒå›´å†…å±äºæ›´é«˜åˆ†ä½çš„æ¶ˆè´¹æ—¥ï¼ˆæŒ‰æœ¬æœŸé‡‘é¢åˆ†å¸ƒè‡ªåŠ¨åˆ†æ¡£ï¼‰ã€‚`
              : `èŒƒå›´ï¼š${appState.period.start} ~ ${appState.period.end}ï¼›é¢œè‰²ç”±ç»¿åˆ°çº¢å†åˆ°ç´«ï¼Œè¡¨ç¤ºåœ¨å½“å‰èŒƒå›´å†…å±äºæ›´é«˜åˆ†ä½çš„æ¶ˆè´¹æ—¥ï¼ˆæŒ‰æœ¬æœŸé‡‘é¢åˆ†å¸ƒè‡ªåŠ¨åˆ†æ¡£ï¼‰ã€‚`;
        }
        return;
      }

      // è®¡ç®—åˆ†ä½æ¡£ä½
      const sorted = amounts.slice().sort((a, b) => a - b);
      const q = (p) => sorted[Math.floor((sorted.length - 1) * p)];
      const q1 = q(0.1);
      const q2 = q(0.2);
      const q3 = q(0.3);
      const q4 = q(0.4);
      const q5 = q(0.5);
      const q6 = q(0.6);
      const q7 = q(0.7);
      const q8 = q(0.8);
      const q9 = q(0.9);

      const bucketLevel = (amt) => {
        if (amt <= 0) return 0;
        if (amt <= q1) return 1;
        if (amt <= q2) return 2;
        if (amt <= q3) return 3;
        if (amt <= q4) return 4;
        if (amt <= q5) return 5;
        if (amt <= q6) return 6;
        if (amt <= q7) return 7;
        if (amt <= q8) return 8;
        if (amt < q9) return 9;
        return 10;
      };

      // ä½¿ç”¨ renderAll å·²è®¡ç®—å¥½çš„ appState.periodï¼ˆæœ¬è´¦æœŸæˆ–å…¨éƒ¨è´¦æœŸï¼‰
      const periodStart = parseYMDLocal(appState.period.start);
      const periodEnd = parseYMDLocal(appState.period.end);

      // å¯¹é½åˆ°å‘¨ä¸€ï¼Œåšâ€œå‘¨ x æ˜ŸæœŸâ€çš„æ ¼å­
      const startDow = (periodStart.getDay() + 6) % 7; // 0=Mon..6=Sun
      const alignedStart = new Date(periodStart);
      alignedStart.setDate(alignedStart.getDate() - startDow);

      const totalDays =
        Math.floor((periodEnd - alignedStart) / 86400000) + 1;
      const weeks = Math.max(1, Math.ceil(totalDays / 7));

      const dayLabels = ["å‘¨ä¸€", "å‘¨äºŒ", "å‘¨ä¸‰", "å‘¨å››", "å‘¨äº”", "å‘¨å…­", "å‘¨æ—¥"];
      const weekLabels = Array.from({ length: weeks }, (_, i) => "W" + (i + 1));

      const z = Array.from({ length: weeks }, () =>
        Array.from({ length: 7 }, () => null)
      );
      const text = Array.from({ length: weeks }, () =>
        Array.from({ length: 7 }, () => "")
      );
      const customData = Array.from({ length: weeks }, () =>
        Array.from({ length: 7 }, () => null)
      );

      for (let w = 0; w < weeks; w++) {
        for (let i = 0; i < 7; i++) {
          const d = new Date(alignedStart);
          d.setDate(alignedStart.getDate() + w * 7 + i);

          if (d < periodStart || d > periodEnd) continue;

          const ds = formatDateLocal(d);
          const amt = Number(daily[ds] || 0);

          if (amt <= 0) {
            z[w][i] = null;
            text[w][i] = `${ds}<br>Â¥0.00`;
            customData[w][i] = ds;
            continue;
          }

          const level = bucketLevel(amt);
          const norm = level / 10;

          z[w][i] = norm;
          text[w][i] = `${ds}<br>Â¥${amt.toFixed(2)}`;
          customData[w][i] = ds;
        }
      }

      const colorscale = [
        [0.0, "#00c853"],
        [0.1, "#4ddf50"],
        [0.2, "#aeea00"],
        [0.3, "#ffd600"],
        [0.4, "#ffab00"],
        [0.5, "#ff9100"],
        [0.6, "#ff6d00"],
        [0.7, "#ff3d00"],
        [0.85, "#d500f9"],
        [1.0, "#aa00ff"],
      ];

      const textColor = isLight ? "#64748b" : "#cbd5f5";

      const trace = {
        type: "heatmap",
        z,
        x: dayLabels,
        y: weekLabels,
        text,
        customdata: customData,
        hoverinfo: "text",
        showscale: false,
        xgap: 2,
        ygap: 2,
        colorscale,
      };

      const layout = {
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        font: { color: textColor },
        margin: { t: 8, l: 40, r: 10, b: 24 },
        xaxis: {
          showgrid: false,
          zeroline: false,
          showticklabels: true,
        },
        yaxis: {
          showgrid: false,
          zeroline: false,
          showticklabels: true,
        },
      };

      Plotly.newPlot("heatmapDiv", [trace], layout, {
        displayModeBar: false,
      });

      const heatDiv = document.getElementById("heatmapDiv");
      if (heatDiv && typeof showDayDetail === "function") {
        heatDiv.on("plotly_click", function (evt) {
          if (!evt || !evt.points || !evt.points.length) return;
          const pt = evt.points[0];
          const ds = pt.customdata;
          if (!ds) return;
          showDayDetail(ds);
        });
      }

      if (hint) {
        hint.innerText =
          appState.scope === "all"
            ? `èŒƒå›´ï¼šå…¨éƒ¨è´¦æœŸï¼ˆ${appState.period.start} ~ ${appState.period.end}ï¼‰ï¼›é¢œè‰²ç”±ç»¿åˆ°çº¢å†åˆ°ç´«ï¼Œè¡¨ç¤ºåœ¨å½“å‰èŒƒå›´å†…å±äºæ›´é«˜åˆ†ä½çš„æ¶ˆè´¹æ—¥ï¼ˆæŒ‰æœ¬æœŸé‡‘é¢åˆ†å¸ƒè‡ªåŠ¨åˆ†æ¡£ï¼‰ã€‚`
            : `èŒƒå›´ï¼š${appState.period.start} ~ ${appState.period.end}ï¼›é¢œè‰²ç”±ç»¿åˆ°çº¢å†åˆ°ç´«ï¼Œè¡¨ç¤ºåœ¨å½“å‰èŒƒå›´å†…å±äºæ›´é«˜åˆ†ä½çš„æ¶ˆè´¹æ—¥ï¼ˆæŒ‰æœ¬æœŸé‡‘é¢åˆ†å¸ƒè‡ªåŠ¨åˆ†æ¡£ï¼‰ã€‚`;
      }
    }

    function showDayDetail(dateStr) {
      const list = getStatTransactions().filter(
        (t) => t.date === dateStr && inCurrentPeriod(t)
      );
      const dayDetail = document.getElementById("dayDetail");
      const zh = (() => {
        const [y, m, d] = dateStr.split("-");
        return Number(m) + "æœˆ" + Number(d) + "æ—¥";
      })();
      if (!list.length) {
        dayDetail.innerText = zh + "ï¼šæ— è®°å½•";
        return;
      }
      const sum = sumAmount(list);
      const brief = list
        .map(
          (t) =>
            `${t.category_level1}-${t.category_level2 || "-"} Â¥${t.amount.toFixed(
              2
            )}`
        )
        .join("ï¼›");
      dayDetail.innerText =
        `${zh} å…± Â¥${sum.toFixed(2)}ï¼š` + brief;
    }

    /* ========== æ˜ç»†åˆ—è¡¨ ========== */
    function renderList(list) {
      const html = list
        .map(
          (t) => `
        <div class="tx-item">
          <div>
            <div>${t.date.slice(5)}</div>
            <div class="tx-meta">${t.account || ""}</div>
          </div>
          <div>
            <div style="font-weight:600;">${
              t.category_level1 || "-"
            } - ${t.category_level2 || "-"}</div>
            <div class="tx-meta">${t.description || ""}</div>
          </div>
          <div style="text-align:right; color:${
            t.category_level1 === "æ”¶å…¥"
              ? "var(--green)"
              : "var(--text)"
          }">
            ${t.category_level1 === "æ”¶å…¥" ? "+" : "-"}Â¥${t.amount.toFixed(
            2
          )}
          </div>
        </div>
      `
        )
        .join("");
      document.getElementById("txList").innerHTML =
        html || '<div class="label">å½“å‰èŒƒå›´å†…æš‚æ— è®°å½•ã€‚</div>';
    }

    /* ========== å•ç¬”è®°è´¦ / æ‰¹é‡å¯¼å…¥ / å¯¼å‡º ========== */
    async function submitSingle() {
      const rawDate =
        document.getElementById("inDate").value || appState.today;
      const date = normalizeDateInput(rawDate);
      const amount = parseFloat(
        document.getElementById("inAmount").value
      );
      const cat1 = document.getElementById("inCat1").value;
      const cat2 = document.getElementById("inCat2").value;
      const desc = document.getElementById("inDesc").value;
      const acc = document.getElementById("inAcc").value;
      const book = document.getElementById("inBook").value || "ä¸»è´¦";
      const xiaoVal = document.getElementById("inXiao").value;
      const is_xiaoe = xiaoVal === "æ˜¯";

      if (!amount) {
        alert("é‡‘é¢å¿…å¡«");
        return;
      }
      const base = date.replace(/-/g, "");
      const suffix = String(Math.floor(Math.random() * 10000)).padStart(
        4,
        "0"
      );
      const tx_id = `${base}-${suffix}`;
      const tx = {
        tx_id,
        date,
        amount,
        category_level1: cat1,
        category_level2: cat2,
        description: desc,
        account: acc,
        book,
        is_xiaoe,
      };
      const res = await apiPostJson("/transactions", tx);
      if (res) {
        alert("è®°è´¦æˆåŠŸ");
        document.getElementById("inAmount").value = "";
        document.getElementById("inDesc").value = "";
        loadTransactions();
      }
    }

    async function submitBatch() {
      const raw = document.getElementById("csvInput").value.trim();
      if (!raw) {
        alert("è¯·å…ˆç²˜è´´ä¸€ç‚¹æ•°æ®");
        return;
      }
      const resultEl = document.getElementById("importResult");
      const errorsEl = document.getElementById("importErrors");
      resultEl.innerText = "å¯¼å…¥ä¸­...";
      if (errorsEl) errorsEl.innerText = "";
      const lines = raw
        .split(/\r?\n/)
        .map((l) => l.trim())
        .filter(Boolean);
      let success = 0;
      const errors = [];
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const cols = line.split(",");
        if (cols.length < 9) {
          errors.push(
            `ç¬¬ ${i + 1} è¡Œåˆ—æ•°ä¸è¶³ï¼ˆå®é™… ${cols.length} åˆ—ï¼‰\n${line}`
          );
          continue;
        }
        let [
          tx_id,
          date,
          amountStr,
          cat1,
          cat2,
          desc,
          account,
          book,
          xiaoeStr,
        ] = cols.map((s) => s.trim());
        date = normalizeDateInput(date);
        const amount = Number(amountStr);
        if (!date || !amount) {
          errors.push(
            `ç¬¬ ${i + 1} è¡Œæ—¥æœŸæˆ–é‡‘é¢æœ‰é—®é¢˜\n${line}`
          );
          continue;
        }
        const lower = xiaoeStr.toLowerCase();
        const is_xiaoe =
          xiaoeStr === "æ˜¯" ||
          xiaoeStr === "1" ||
          lower === "true" ||
          lower === "yes";
        const body = {
          tx_id,
          date,
          amount,
          category_level1: cat1,
          category_level2: cat2,
          description: desc,
          account,
          book,
          is_xiaoe,
        };
        const res = await apiPostJson("/transactions", body);
        if (res) success++;
        else
          errors.push(
            `ç¬¬ ${i + 1} è¡Œåå°è¿”å›é”™è¯¯\n${line}`
          );
      }
      resultEl.innerText = `æˆåŠŸå¯¼å…¥ ${success} æ¡ï¼Œé”™è¯¯ ${errors.length} æ¡`;
      if (errorsEl) {
        errorsEl.innerText = errors.join("\n\n");
      }
      loadTransactions();
    }

    function switchTab(t) {
      document
        .querySelectorAll(".tab")
        .forEach((e) => e.classList.remove("active"));
      document
        .querySelectorAll(".tab-content")
        .forEach((e) => e.classList.remove("active"));
      if (t === "single") {
        document
          .getElementById("tab-btn-single")
          .classList.add("active");
        document
          .getElementById("tab-single")
          .classList.add("active");
      } else {
        document
          .getElementById("tab-btn-batch")
          .classList.add("active");
        document
          .getElementById("tab-batch")
          .classList.add("active");
      }
    }

    function fillDemo() {
      document.getElementById("csvInput").value =
        "20251001-0001,2025-10-01,44.65,å¨±ä¹,å‡ºå»ç©,ç”µå½±+çˆ†ç±³èŠ±,ä½™é¢,ä¸»è´¦,å¦\n" +
        "20251001-0002,2025-10-01,36,ç”Ÿæ´»,äº¤é€š,åœè½¦,ä½™é¢,ä¸»è´¦,å¦";
    }

    async function exportCSV() {
      let url = `${LEDGER_API_BASE}/export`;
      if (appState.scope !== "all") {
        url += `?from=${encodeURIComponent(
          appState.period.start
        )}&to=${encodeURIComponent(appState.period.end)}`;
      }
      try {
        const res = await fetch(url, {
          headers: buildHeaders(false),
        });
        if (res.status === 401) {
          alert("è®¿é—®è¢«æ‹’ç»ï¼Œè¯·æ£€æŸ¥è®¿é—®å¯†ç ");
          return;
        }
        if (!res.ok) {
          alert("å¯¼å‡ºå¤±è´¥ï¼š" + res.status);
          return;
        }
        const blob = await res.blob();
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "ledger_export.csv";
        document.body.appendChild(a);
        a.click();
        a.remove();
      } catch (e) {
        alert("å¯¼å‡ºè¿‡ç¨‹ä¸­ç½‘ç»œé”™è¯¯ï¼š" + e.message);
      }
    }
  </script>
</body>
</html>
